---
layout: post
title: Entities are not resources
tags:
- Tumble
status: publish
type: post
published: true
meta:
  dsq_thread_id: '17413888'
---
<p>I've been thinking about data access a lot lately from two fronts:</p>  <ol>   <li>Distributed--in particular HTTP, siding primarily with standardizing on the Atom Publishing Protocol as the default implementation of REST </li>    <li>In-process--in particular Java</li> </ol>  <p>As a result of my pondering, I believe there are two larger classifications of applications in the real world:</p>  <ul>   <li>Entity-oriented applications define a clear set of entities for the application and use them for all operations. </li>    <li>Data-oriented applications split up code in one logic layer and one data access layer. However, the data access layer manipulates the tables directly, not always passing through an entire entity representation.</li> </ul>  <p>In my opinion, the data-oriented method is the way people actually code their applications. Recently, I've spent time on a mailing list trying to teach the principles of REST, a highly arguable topic because it means different things to different people. To some, it means anything HTTP that isn't SOAP. To others, it is an architectural style, HTTP the way it was designed.</p>  <p>I side with the later.</p>  <p>So, in thinking about distributed data access in context of the discussions on this mailing list, I've come to realize that people are cramming their traditional, in-process data access mindset into HTTP. Its not their fault, they've been conditioned that way because of API creators.</p>  <p>As an example, consider the typical scenario below:</p>  <p>You have <strong>customer</strong> and <strong>order</strong> tables and need to display in a grid each customer and the total number of orders.</p>  <p>In entity-oriented applications, there are two primitives: entity (or resource in REST) and lists of entities. Here, the developer codes to simply load all the customers. Then, in each customer entity, a link points to list of order entities.</p>  <p>In data-oriented applications, most of the time, you will have a query in your access layer such as &quot;SELECT c.name, count(o) FROM customer c INNER JOIN order o ON c.id = o.customer_id GROUP BY c.name&quot;. The result of this query can not be mapped to an entity. If you want to use the result, you will need to one of the following:</p>  <ul>   <li>Bind the ResultSet to managable grid of sorts </li>    <li>Load the ResultSet into some disconnected structure for later usage      <ul>       <li>DataSet </li>        <li>XML </li>        <li>other structure</li>     </ul>   </li> </ul>  <p>Both solutions can lead to clean, well-defined applications. It all depends on your needs.</p>  <p>In the data-oriented application, it is often hard to know what are the data structures that are passed across tiers because they may vary by implementation. For instance, Array for a single column select, XML for complex results, DataSet, custom classes (Hibernate, JPA).</p>  <p>However, in entity-oriented appications, other problems may appear: performance, partial entity loading, complex database structure, etc.</p>
